(*
	NAMING.SCPT
	By Chris Sauve of [pxldot](http://pxldot.com).
	See README for details.
*)-- The delimiters for text entry; feel free to change them to your liking!property replaceDelimiter : ">" -- Only one characterproperty pairDelimiter : "//"property occuranceDelimiter : "*" -- Only one character-- Don't change theseset replacePairFound to falsetell application "OmniFocus"	tell first document window of front document		set tasksSelected to value of (selected trees of content where (class of its value is not item) and (class of its value is not folder))		if length of tasksSelected is 0 then			set tasksSelected to value of (selected trees of sidebar where (its class is not folder) and (its class is not item))			if length of tasksSelected is 0 then				display alert "You didn't select any OmniFocus tasks."				return			end if		end if	end tellend tellset inputDialog to "What replacement would you like to make? Use the format: currentString " & replaceDelimiter & " replacementString (you can do multiple replacements by separating pairs with a " & quote & pairDelimiter & quote & " and designate the number of occurances using " & quote & occuranceDelimiter & quote & "."set defaultAnswer to "currentString " & replaceDelimiter & " replacementString"try	display dialog ¬		inputDialog default answer defaultAnswer	set replacementInput to text returned of resulton error errorText number errorNumber	if errorNumber is -128 then		return	end ifend tryset orderOfInput to {}repeat with i from 1 to (count of (characters in replacementInput))	tell character i of replacementInput		if it is replaceDelimiter then			set orderOfInput to orderOfInput & {"replace", "replacement"}			set replacePairFound to true		else if it is occuranceDelimiter then			set end of orderOfInput to "occurance"		end if	end tellend repeatif not replacePairFound then	display alert "No replacement pairs were found."	returnelse	set text item delimiters to {" " & replaceDelimiter & " ", replaceDelimiter, " " & pairDelimiter & " ", pairDelimiter, " " & occuranceDelimiter & " ", occuranceDelimiter}	copy every text item of replacementInput to inputList	set text item delimiters to ""		set currentString to {}	set replacementString to {}	set occuranceString to {}	repeat with i from 1 to (length of orderOfInput)		if item i of orderOfInput is "replace" then			set end of currentString to (item i of inputList)			set end of replacementString to ((item (i + 1)) of inputList)			try				if (item (i + 2)) of orderOfInput is "occurance" then					set end of occuranceString to ((item (i + 2)) of inputList) as text				else					set end of occuranceString to missing value				end if			on error				set end of occuranceString to missing value			end try		end if	end repeat		tell application "OmniFocus"		repeat with i from 1 to (length of tasksSelected)			repeat with j from 1 to (length of currentString)				set the (name of (item i of tasksSelected)) to my findAndReplace(((name of (item i of tasksSelected)) as string), item j of currentString, item j of replacementString, item j of occuranceString)				set the (note of (item i of tasksSelected)) to my findAndReplace(((name of (item i of tasksSelected)) as string), item j of currentString, item j of replacementString, item j of occuranceString)			end repeat		end repeat		set my text item delimiters to ""	end tellend ifto findAndReplace(wholeString, replaceThis, withThis, thisManyTimes)	set my text item delimiters to replaceThis	set nameTempList to every text item of wholeString	set numberOfOccurances to ((length of nameTempList) - 1)	if thisManyTimes is missing value then set thisManyTimes to numberOfOccurances	set stopReplacementAfter to (smallerOf(thisManyTimes, numberOfOccurances) + 1)	if (stopReplacementAfter - 1) is numberOfOccurances then		set my text item delimiters to withThis		set replacedText to ((items 1 thru stopReplacementAfter of nameTempList) as text)	else		set my text item delimiters to withThis		set tempNameReplacement to ((items 1 thru stopReplacementAfter of nameTempList) as text) & replaceThis		set my text item delimiters to replaceThis		set tempNameNoReplacement to ((items (stopReplacementAfter + 1) thru -1 of nameTempList) as text)		set replacedText to (tempNameReplacement & tempNameNoReplacement)	end if	set my text item delimiters to ""	return replacedTextend findAndReplaceon smallerOf(num1, num2)	if num1 ≤ num2 then		return num1	else		return num2	end ifend smallerOf